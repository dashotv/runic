// Code generated by github.com/dashotv/golem. DO NOT EDIT.
package client

import (
	"context"
	"fmt"

	"github.com/dashotv/fae"
)

type ReleasesService struct {
	client *Client
}

// NewReleases makes a new client for accessing Releases services.
func NewReleasesService(client *Client) *ReleasesService {
	return &ReleasesService{
		client: client,
	}
}

type ReleasesIndexRequest struct {
	Page  int `json:"page"`
	Limit int `json:"limit"`
}

type ReleasesIndexResponse struct {
	*Response
	Result []*Release `json:"result"`
	Total  int64      `json:"total"`
}

func (s *ReleasesService) Index(ctx context.Context, req *ReleasesIndexRequest) (*ReleasesIndexResponse, error) {
	result := &ReleasesIndexResponse{Response: &Response{}}
	resp, err := s.client.Resty.R().
		SetContext(ctx).
		SetBody(req).
		SetResult(result).
		SetQueryParam("page", fmt.Sprintf("%v", req.Page)).
		SetQueryParam("limit", fmt.Sprintf("%v", req.Limit)).
		Get("/releases/")
	if err != nil {
		return nil, fae.Wrap(err, "failed to make request")
	}
	if !resp.IsSuccess() {
		return nil, fae.Errorf("%d: %v", resp.StatusCode(), resp.String())
	}
	if result.Error {
		return nil, fae.New(result.Message)
	}

	return result, nil
}

type ReleasesCreateRequest struct {
	Subject *Release `json:"subject"`
}

type ReleasesCreateResponse struct {
	*Response
	Result *Release `json:"result"`
}

func (s *ReleasesService) Create(ctx context.Context, req *ReleasesCreateRequest) (*ReleasesCreateResponse, error) {
	result := &ReleasesCreateResponse{Response: &Response{}}
	resp, err := s.client.Resty.R().
		SetContext(ctx).
		SetBody(req).
		SetResult(result).
		Post("/releases/")
	if err != nil {
		return nil, fae.Wrap(err, "failed to make request")
	}
	if !resp.IsSuccess() {
		return nil, fae.Errorf("%d: %v", resp.StatusCode(), resp.String())
	}
	if result.Error {
		return nil, fae.New(result.Message)
	}

	return result, nil
}

type ReleasesShowRequest struct {
	ID string `json:"id"`
}

type ReleasesShowResponse struct {
	*Response
	Result *Release `json:"result"`
}

func (s *ReleasesService) Show(ctx context.Context, req *ReleasesShowRequest) (*ReleasesShowResponse, error) {
	result := &ReleasesShowResponse{Response: &Response{}}
	resp, err := s.client.Resty.R().
		SetContext(ctx).
		SetBody(req).
		SetResult(result).
		SetPathParam("id", fmt.Sprintf("%v", req.ID)).
		Get("/releases/{id}")
	if err != nil {
		return nil, fae.Wrap(err, "failed to make request")
	}
	if !resp.IsSuccess() {
		return nil, fae.Errorf("%d: %v", resp.StatusCode(), resp.String())
	}
	if result.Error {
		return nil, fae.New(result.Message)
	}

	return result, nil
}

type ReleasesUpdateRequest struct {
	ID      string   `json:"id"`
	Subject *Release `json:"subject"`
}

type ReleasesUpdateResponse struct {
	*Response
	Result *Release `json:"result"`
}

func (s *ReleasesService) Update(ctx context.Context, req *ReleasesUpdateRequest) (*ReleasesUpdateResponse, error) {
	result := &ReleasesUpdateResponse{Response: &Response{}}
	resp, err := s.client.Resty.R().
		SetContext(ctx).
		SetBody(req).
		SetResult(result).
		SetPathParam("id", fmt.Sprintf("%v", req.ID)).
		Put("/releases/{id}")
	if err != nil {
		return nil, fae.Wrap(err, "failed to make request")
	}
	if !resp.IsSuccess() {
		return nil, fae.Errorf("%d: %v", resp.StatusCode(), resp.String())
	}
	if result.Error {
		return nil, fae.New(result.Message)
	}

	return result, nil
}

type ReleasesSettingsRequest struct {
	ID      string   `json:"id"`
	Setting *Setting `json:"setting"`
}

type ReleasesSettingsResponse struct {
	*Response
	Result *Release `json:"result"`
}

func (s *ReleasesService) Settings(ctx context.Context, req *ReleasesSettingsRequest) (*ReleasesSettingsResponse, error) {
	result := &ReleasesSettingsResponse{Response: &Response{}}
	resp, err := s.client.Resty.R().
		SetContext(ctx).
		SetBody(req).
		SetResult(result).
		SetPathParam("id", fmt.Sprintf("%v", req.ID)).
		Patch("/releases/{id}")
	if err != nil {
		return nil, fae.Wrap(err, "failed to make request")
	}
	if !resp.IsSuccess() {
		return nil, fae.Errorf("%d: %v", resp.StatusCode(), resp.String())
	}
	if result.Error {
		return nil, fae.New(result.Message)
	}

	return result, nil
}

type ReleasesDeleteRequest struct {
	ID string `json:"id"`
}

type ReleasesDeleteResponse struct {
	*Response
	Result *Release `json:"result"`
}

func (s *ReleasesService) Delete(ctx context.Context, req *ReleasesDeleteRequest) (*ReleasesDeleteResponse, error) {
	result := &ReleasesDeleteResponse{Response: &Response{}}
	resp, err := s.client.Resty.R().
		SetContext(ctx).
		SetBody(req).
		SetResult(result).
		SetPathParam("id", fmt.Sprintf("%v", req.ID)).
		Delete("/releases/{id}")
	if err != nil {
		return nil, fae.Wrap(err, "failed to make request")
	}
	if !resp.IsSuccess() {
		return nil, fae.Errorf("%d: %v", resp.StatusCode(), resp.String())
	}
	if result.Error {
		return nil, fae.New(result.Message)
	}

	return result, nil
}

type ReleasesSearchRequest struct {
	Page       int    `json:"page"`
	Limit      int    `json:"limit"`
	Source     string `json:"source"`
	Kind       string `json:"kind"`
	Resolution string `json:"resolution"`
	Group      string `json:"group"`
	Website    string `json:"website"`
}

type ReleasesSearchResponse struct {
	*Response
	Result []*Release `json:"result"`
}

func (s *ReleasesService) Search(ctx context.Context, req *ReleasesSearchRequest) (*ReleasesSearchResponse, error) {
	result := &ReleasesSearchResponse{Response: &Response{}}
	resp, err := s.client.Resty.R().
		SetContext(ctx).
		SetBody(req).
		SetResult(result).
		SetQueryParam("page", fmt.Sprintf("%v", req.Page)).
		SetQueryParam("limit", fmt.Sprintf("%v", req.Limit)).
		SetQueryParam("source", fmt.Sprintf("%v", req.Source)).
		SetQueryParam("kind", fmt.Sprintf("%v", req.Kind)).
		SetQueryParam("resolution", fmt.Sprintf("%v", req.Resolution)).
		SetQueryParam("group", fmt.Sprintf("%v", req.Group)).
		SetQueryParam("website", fmt.Sprintf("%v", req.Website)).
		Get("/releases/search")
	if err != nil {
		return nil, fae.Wrap(err, "failed to make request")
	}
	if !resp.IsSuccess() {
		return nil, fae.Errorf("%d: %v", resp.StatusCode(), resp.String())
	}
	if result.Error {
		return nil, fae.New(result.Message)
	}

	return result, nil
}

type ReleasesMoviesResponse struct {
	*Response
	Result []*PopularMovie `json:"result"`
}

func (s *ReleasesService) Movies(ctx context.Context) (*ReleasesMoviesResponse, error) {
	result := &ReleasesMoviesResponse{Response: &Response{}}
	resp, err := s.client.Resty.R().
		SetContext(ctx).
		SetResult(result).
		Get("/releases/popular_movies")
	if err != nil {
		return nil, fae.Wrap(err, "failed to make request")
	}
	if !resp.IsSuccess() {
		return nil, fae.Errorf("%d: %v", resp.StatusCode(), resp.String())
	}
	if result.Error {
		return nil, fae.New(result.Message)
	}

	return result, nil
}
